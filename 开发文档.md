# RAG实训报告生成系统开发文档

## 1. 项目概述

RAG实训报告生成系统是一个基于检索增强生成（Retrieval-Augmented Generation）技术的智能文档生成系统。该系统能够自动处理用户上传的资料，利用大语言模型生成结构化的实训报告。

### 1.1 主要功能
- 文档上传与处理（支持多种格式）
- 智能报告生成
- Word模板渲染
- 封面和正文自动合并
- 向量数据库检索增强
- 图片处理与插入
- 实时进度反馈
- 错误处理与日志记录

### 1.2 技术栈
- 后端：FastAPI + Python
- 前端：原生JavaScript + CSS3
- AI：Qwen/OpenAI API
- 数据库：ChromaDB（向量数据库）
- 文档处理：python-docx, docxtpl
- 部署：Docker + Docker Compose

## 2. 系统架构

### 2.1 整体架构
```
RAG实训报告生成系统
├── 前端层
│   ├── 文件上传模块
│   ├── 表单处理模块
│   └── 报告生成模块
├── 后端层
│   ├── FastAPI服务
│   ├── AI服务模块
│   └── 文档处理模块
└── 存储层
    ├── 向量数据库
    ├── 文件存储
    └── 临时文件
```

### 2.2 目录结构
```
rag-report-generator/
├── app.py                 # FastAPI主应用
├── static/               # 静态资源
│   ├── css/
│   │   └── style.css    # 样式文件
│   └── js/
│       └── main.js      # 前端逻辑
├── templates/           # HTML模板
│   └── index.html      # 主页面
├── services/           # 服务模块
│   ├── ai_service.py   # AI服务
│   └── report_generator.py # 报告生成服务
├── uploads/           # 上传文件目录
├── temp/             # 临时文件目录
├── chroma_db/        # 向量数据库目录
└── docker/           # Docker配置
```

## 3. 核心模块说明

### 3.1 AI服务模块 (services/ai_service.py)

#### 3.1.1 模块功能
- 向量数据库管理
- 文档检索与相似度计算
- AI模型调用与内容生成
- 上下文管理

#### 3.1.2 核心实现
```python
import os
import chromadb
import aiohttp
import json
from typing import List, Dict, Any

class AIService:
    def __init__(self):
        self.model_name = os.getenv("AI_MODEL_NAME", "qwen2.5:7b")
        self.api_key = os.getenv("AI_API_KEY")
        self.api_url = os.getenv("AI_API_URL", "http://localhost:11434/api/generate")
        
        # 初始化ChromaDB客户端
        self.chroma_client = chromadb.PersistentClient(path="./chroma_db")
        self.collection = self.chroma_client.get_or_create_collection(
            name="report_documents",
            metadata={"description": "实训报告文档向量存储"}
        )

    async def add_documents_to_vectorstore(self, documents: List[Dict[str, Any]]) -> None:
        """添加文档到向量数据库"""
        try:
            for doc in documents:
                # 文档分块处理
                chunks = self._split_document(doc['content'])
                for i, chunk in enumerate(chunks):
                    self.collection.add(
                        documents=[chunk],
                        metadatas=[{
                            'source': doc['filename'],
                            'chunk_id': i,
                            'file_type': doc['file_type']
                        }],
                        ids=[f"{doc['filename']}_{i}"]
                    )
        except Exception as e:
            print(f"添加文档到向量数据库失败: {e}")
            raise

    async def search_similar_documents(self, query: str, top_k: int = 5) -> List[Dict]:
        """检索相似文档"""
        try:
            results = self.collection.query(
                query_texts=[query],
                n_results=top_k
            )
            
            # 格式化返回结果
            documents = []
            for i in range(len(results['documents'][0])):
                documents.append({
                    'content': results['documents'][0][i],
                    'metadata': results['metadatas'][0][i],
                    'distance': results['distances'][0][i] if 'distances' in results else None
                })
            
            return documents
        except Exception as e:
            print(f"检索相似文档失败: {e}")
            return []

    async def generate_report_with_prompt(self, query: str, prompt: str, context: str = "") -> str:
        """生成报告内容"""
        try:
            # 构建完整的提示词
            full_prompt = f"""
            基于以下上下文信息，请生成报告内容：

            上下文信息：
            {context}

            具体要求：
            {prompt}

            查询内容：
            {query}

            请生成详细、专业的报告内容。
            """

            # 调用AI模型
            async with aiohttp.ClientSession() as session:
                payload = {
                    "model": self.model_name,
                    "prompt": full_prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.7,
                        "top_p": 0.9,
                        "max_tokens": 2000
                    }
                }
                
                async with session.post(self.api_url, json=payload) as response:
                    if response.status == 200:
                        result = await response.json()
                        return result.get('response', '')
                    else:
                        raise Exception(f"AI服务调用失败: {response.status}")
                        
        except Exception as e:
            print(f"生成报告失败: {e}")
            return "生成报告时发生错误，请稍后重试。"

    def _split_document(self, content: str, chunk_size: int = 1000) -> List[str]:
        """文档分块处理"""
        chunks = []
        words = content.split()
        
        for i in range(0, len(words), chunk_size):
            chunk = ' '.join(words[i:i + chunk_size])
            chunks.append(chunk)
            
        return chunks
```

#### 3.1.3 配置说明
```python
# 环境变量配置
AI_API_URL=http://localhost:11434/api/generate  # AI服务地址
AI_MODEL_NAME=qwen-plus                       # 模型名称
AI_API_KEY= api_key                         # API密钥（可选）

# 向量数据库配置
CHROMA_DB_PATH=./chroma_db                      # 数据库存储路径
CHUNK_SIZE=1000                                 # 文档分块大小
TOP_K_RESULTS=5                                 # 检索结果数量
```

### 3.2 报告生成服务 (services/report_generator.py)

#### 3.2.1 模块功能
- Word文档模板处理
- 内容渲染与格式化
- 图片插入与处理
- 文档合并与输出

#### 3.2.2 核心实现
```python
import os
import shutil
from typing import Dict, List, Any
from docxtpl import DocxTemplate
from docx import Document
from docx.shared import Inches
from PIL import Image
import io

class ReportGenerator:
    def __init__(self):
        self.supported_image_extensions = {'.png', '.jpg', '.jpeg', '.gif', '.bmp'}
        self.max_image_width = 6.0  # 最大图片宽度（英寸）
        self.max_image_height = 4.0  # 最大图片高度（英寸）

    async def generate_report(self, template_path: str, report_content: Dict[str, Any], 
                            user_info: Dict[str, str], images: List[str], session_dir: str) -> str:
        """生成完整报告"""
        try:
            # 创建临时工作目录
            work_dir = os.path.join(session_dir, "work")
            os.makedirs(work_dir, exist_ok=True)
            
            # 处理封面模板
            cover_path = await self._process_cover_template(template_path, user_info, work_dir)
            
            # 处理正文模板
            body_path = await self._process_body_template(template_path, report_content, images, work_dir)
            
            # 合并文档
            final_path = await self._merge_documents(cover_path, body_path, session_dir)
            
            return final_path
            
        except Exception as e:
            print(f"生成报告失败: {e}")
            raise

    async def _process_cover_template(self, template_path: str, user_info: Dict[str, str], 
                                    work_dir: str) -> str:
        """处理封面模板"""
        try:
            cover_template = DocxTemplate(os.path.join(template_path, "cover_template.docx"))
            
            # 准备封面数据
            cover_data = {
                'name': user_info.get('name', ''),
                'student_id': user_info.get('student_id', ''),
                'class_name': user_info.get('class_name', ''),
                'instructor': user_info.get('instructor', ''),
                'project_name': user_info.get('project_name', ''),
                'date': user_info.get('date', ''),
                'semester': user_info.get('semester', '')
            }
            
            # 渲染封面
            cover_template.render(cover_data)
            cover_path = os.path.join(work_dir, "cover.docx")
            cover_template.save(cover_path)
            
            return cover_path
            
        except Exception as e:
            print(f"处理封面模板失败: {e}")
            raise

    async def _process_body_template(self, template_path: str, report_content: Dict[str, Any], 
                                   images: List[str], work_dir: str) -> str:
        """处理正文模板"""
        try:
            body_template = DocxTemplate(os.path.join(template_path, "body_template.docx"))
            
            # 处理内容中的图片
            processed_content = self._process_content_with_images(report_content, images, work_dir)
            
            # 渲染正文
            body_template.render(processed_content)
            body_path = os.path.join(work_dir, "body.docx")
            body_template.save(body_path)
            
            return body_path
            
        except Exception as e:
            print(f"处理正文模板失败: {e}")
            raise

    def _process_content_with_images(self, content: Dict[str, Any], images: List[str], 
                                   work_dir: str) -> Dict[str, Any]:
        """处理内容中的图片"""
        processed_content = content.copy()
        
        for key, value in processed_content.items():
            if isinstance(value, str) and '[IMAGE:' in value:
                # 查找图片占位符
                import re
                image_pattern = r'\[IMAGE:(\d+)\]'
                matches = re.findall(image_pattern, value)
                
                for match in matches:
                    image_index = int(match)
                    if image_index < len(images):
                        # 处理图片
                        image_path = images[image_index]
                        processed_image_path = self._process_image(image_path, work_dir)
                        
                        # 替换占位符
                        placeholder = f'[IMAGE:{image_index}]'
                        processed_content[key] = value.replace(placeholder, processed_image_path)
        
        return processed_content

    def _process_image(self, image_path: str, work_dir: str) -> str:
        """处理图片（调整大小、格式转换等）"""
        try:
            with Image.open(image_path) as img:
                # 调整图片大小
                img.thumbnail((self.max_image_width * 96, self.max_image_height * 96))
                
                # 保存处理后的图片
                processed_path = os.path.join(work_dir, f"processed_{os.path.basename(image_path)}")
                img.save(processed_path, format='PNG')
                
                return processed_path
                
        except Exception as e:
            print(f"处理图片失败: {e}")
            return image_path

    async def _merge_documents(self, cover_path: str, body_path: str, session_dir: str) -> str:
        """合并封面和正文"""
        try:
            # 加载文档
            cover_doc = Document(cover_path)
            body_doc = Document(body_path)
            
            # 创建新文档
            merged_doc = Document()
            
            # 复制封面内容
            for element in cover_doc.element.body:
                merged_doc.element.body.append(element)
            
            # 添加分页符
            merged_doc.add_page_break()
            
            # 复制正文内容
            for element in body_doc.element.body:
                merged_doc.element.body.append(element)
            
            # 保存合并后的文档
            final_path = os.path.join(session_dir, "final_report.docx")
            merged_doc.save(final_path)
            
            return final_path
            
        except Exception as e:
            print(f"合并文档失败: {e}")
            raise
```

#### 3.2.3 模板格式说明
```xml
<!-- 封面模板示例 (cover_template.docx) -->
<w:document>
  <w:body>
    <w:p>
      <w:r>
        <w:t>{{project_name}}</w:t>
      </w:r>
    </w:p>
    <w:p>
      <w:r>
        <w:t>姓名：{{name}}</w:t>
      </w:r>
    </w:p>
    <!-- 更多字段... -->
  </w:body>
</w:document>

<!-- 正文模板示例 (body_template.docx) -->
<w:document>
  <w:body>
    <w:p>
      <w:r>
        <w:t>{{design_requirements}}</w:t>
      </w:r>
    </w:p>
    <w:p>
      <w:r>
        <w:t>{{knowledge_and_tech}}</w:t>
      </w:r>
    </w:p>
    <!-- 更多内容字段... -->
  </w:body>
</w:document>
```

### 3.3 前端核心逻辑 (static/js/main.js)

#### 3.3.1 模块功能
- 文件上传管理
- 表单数据处理
- 异步请求处理
- 用户界面交互

#### 3.3.2 核心实现
```javascript
// 全局变量
let uploadedFiles = [];
let uploadedTemplates = {};

// 文件上传处理
async function handleCardFileChange(input, type) {
    const files = Array.from(input.files);
    console.log(`处理${type}文件:`, files);
    
    try {
        const formData = new FormData();
        
        if (type === 'template') {
            // 处理模板文件
            files.forEach(file => {
                formData.append('template_files', file);
            });
            
            const response = await fetch('/upload_templates', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                uploadedTemplates = result.templates;
                showMessage('模板上传成功', 'success');
                updateTemplateDisplay();
            } else {
                throw new Error('模板上传失败');
            }
        } else {
            // 处理资料文件
            files.forEach(file => {
                formData.append('files', file);
            });
            
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                uploadedFiles = result.files;
                showMessage('文件上传成功', 'success');
                updateFileDisplay();
            } else {
                throw new Error('文件上传失败');
            }
        }
    } catch (error) {
        console.error('文件上传错误:', error);
        showMessage('文件上传失败: ' + error.message, 'error');
    }
}

// 报告生成
async function generateReport() {
    console.log('开始生成报告...');
    
    // 验证文件上传
    if (uploadedFiles.length === 0) {
        showMessage('请先上传资料文件', 'error');
        return;
    }
    
    if (!uploadedTemplates.cover || !uploadedTemplates.body) {
        showMessage('请先上传模板文件', 'error');
        return;
    }
    
    try {
        // 收集表单数据
        const formData = new FormData();
        
        // 添加查询内容
        const query = document.getElementById('query').value;
        formData.append('query', query);
        
        // 添加用户信息
        const userFields = ['name', 'student_id', 'class_name', 'instructor', 
                           'project_name', 'date', 'semester'];
        userFields.forEach(field => {
            const value = document.getElementById(field).value;
            formData.append(field, value);
        });
        
        // 添加可选字段
        const optionalFields = ['design_requirements', 'knowledge_and_tech', 
                               'completion', 'self_statement'];
        optionalFields.forEach(field => {
            const value = document.getElementById(field).value;
            if (value.trim()) {
                formData.append(field, value);
            }
        });
        
        // 添加模板信息
        formData.append('cover_template', uploadedTemplates.cover);
        formData.append('body_template', uploadedTemplates.body);
        
        console.log('准备发送FormData，包含以下字段:');
        for (let [key, value] of formData.entries()) {
            console.log(`${key}: ${value}`);
        }
        
        // 显示加载状态
        showMessage('正在生成报告，请稍候...', 'info');
        const generateBtn = document.getElementById('generateBtn');
        generateBtn.disabled = true;
        generateBtn.textContent = '生成中...';
        
        // 发送请求
        const response = await fetch('/generate_report', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            showMessage('报告生成成功！', 'success');
            
            // 提供下载链接
            if (result.download_url) {
                const downloadLink = document.createElement('a');
                downloadLink.href = result.download_url;
                downloadLink.download = '实训报告.docx';
                downloadLink.textContent = '下载报告';
                downloadLink.className = 'download-link';
                document.getElementById('resultArea').appendChild(downloadLink);
            }
        } else {
            const errorData = await response.json();
            throw new Error(errorData.detail || '报告生成失败');
        }
        
    } catch (error) {
        console.error('生成报告错误:', error);
        showMessage('生成报告失败: ' + error.message, 'error');
    } finally {
        // 恢复按钮状态
        const generateBtn = document.getElementById('generateBtn');
        generateBtn.disabled = false;
        generateBtn.textContent = '生成报告';
    }
}

// 更新文件显示
function updateFileDisplay() {
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';
    
    uploadedFiles.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
            <span>${file.name}</span>
            <button onclick="removeFile('${file.name}')" class="remove-btn">删除</button>
        `;
        fileList.appendChild(fileItem);
    });
}

// 更新模板显示
function updateTemplateDisplay() {
    const templateList = document.getElementById('templateList');
    templateList.innerHTML = '';
    
    Object.entries(uploadedTemplates).forEach(([type, template]) => {
        const templateItem = document.createElement('div');
        templateItem.className = 'template-item';
        templateItem.innerHTML = `
            <span>${type}: ${template}</span>
            <button onclick="removeTemplate('${type}')" class="remove-btn">删除</button>
        `;
        templateList.appendChild(templateItem);
    });
}

// 删除文件
function removeFile(fileName) {
    uploadedFiles = uploadedFiles.filter(file => file.name !== fileName);
    updateFileDisplay();
    showMessage('文件已删除', 'info');
}

// 删除模板
function removeTemplate(type) {
    delete uploadedTemplates[type];
    updateTemplateDisplay();
    showMessage('模板已删除', 'info');
}

// 显示消息
function showMessage(message, type = 'info') {
    const messageDiv = document.getElementById('message');
    messageDiv.textContent = message;
    messageDiv.className = `message ${type}`;
    messageDiv.style.display = 'block';
    
    // 3秒后自动隐藏
    setTimeout(() => {
        messageDiv.style.display = 'none';
    }, 3000);
}

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', function() {
    console.log('页面加载完成，初始化应用...');
    
    // 绑定事件监听器
    const generateBtn = document.getElementById('generateBtn');
    if (generateBtn) {
        generateBtn.addEventListener('click', generateReport);
    }
    
    // 初始化文件上传监听器
    const fileInputs = document.querySelectorAll('input[type="file"]');
    fileInputs.forEach(input => {
        input.addEventListener('change', function() {
            const type = this.getAttribute('data-type') || 'files';
            handleCardFileChange(this, type);
        });
    });
    
    console.log('应用初始化完成');
});

// 将函数挂载到window对象，以便HTML调用
window.generateReport = generateReport;
```

#### 3.3.3 用户界面组件
```html
<!-- 文件上传区域 -->
<div class="upload-section">
    <div class="upload-card">
        <h3>上传模板文件</h3>
        <input type="file" id="coverTemplate" data-type="template" accept=".docx">
        <input type="file" id="bodyTemplate" data-type="template" accept=".docx">
        <div id="templateList" class="file-list"></div>
    </div>
    
    <div class="upload-card">
        <h3>上传资料文件</h3>
        <input type="file" id="files" data-type="files" multiple accept=".txt,.pdf,.doc,.docx">
        <div id="fileList" class="file-list"></div>
    </div>
</div>

<!-- 表单区域 -->
<div class="form-section">
    <div class="form-group">
        <label for="query">查询内容</label>
        <textarea id="query" required></textarea>
    </div>
    
    <div class="form-row">
        <div class="form-group">
            <label for="name">姓名</label>
            <input type="text" id="name" required>
        </div>
        <div class="form-group">
            <label for="student_id">学号</label>
            <input type="text" id="student_id" required>
        </div>
    </div>
    
    <!-- 更多表单字段... -->
</div>

<!-- 操作区域 -->
<div class="action-section">
    <button id="generateBtn" class="primary-btn">生成报告</button>
</div>

<!-- 消息显示区域 -->
<div id="message" class="message" style="display: none;"></div>

<!-- 结果显示区域 -->
<div id="resultArea" class="result-area"></div>
```

### 3.4 主应用模块 (app.py)

#### 3.4.1 路由设计
```python
from fastapi import FastAPI, File, UploadFile, Form, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import FileResponse
import os
import uuid
from typing import List, Optional

app = FastAPI(title="RAG实训报告生成系统")

# 静态文件和模板配置
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# 服务实例
ai_service = AIService()
report_generator = ReportGenerator()

@app.get("/")
async def read_root(request):
    """主页面"""
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload")
async def upload_files(files: List[UploadFile] = File(...)):
    """上传资料文件"""
    try:
        uploaded_files = []
        session_id = str(uuid.uuid4())
        session_dir = os.path.join("temp", session_id)
        os.makedirs(session_dir, exist_ok=True)
        
        for file in files:
            if file.filename:
                file_path = os.path.join(session_dir, file.filename)
                with open(file_path, "wb") as buffer:
                    content = await file.read()
                    buffer.write(content)
                
                uploaded_files.append({
                    "filename": file.filename,
                    "path": file_path,
                    "size": len(content)
                })
        
        return {"files": uploaded_files, "session_id": session_id}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/upload_templates")
async def upload_templates(template_files: List[UploadFile] = File(...)):
    """上传模板文件"""
    try:
        templates = {}
        template_dir = "templates"
        os.makedirs(template_dir, exist_ok=True)
        
        for file in template_files:
            if file.filename:
                file_path = os.path.join(template_dir, file.filename)
                with open(file_path, "wb") as buffer:
                    content = await file.read()
                    buffer.write(content)
                
                if "cover" in file.filename.lower():
                    templates["cover"] = file_path
                elif "body" in file.filename.lower():
                    templates["body"] = file_path
        
        return {"templates": templates}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/generate_report")
async def generate_report(
    query: str = Form(...),
    name: str = Form(...),
    student_id: str = Form(...),
    class_name: str = Form(...),
    instructor: str = Form(...),
    project_name: str = Form(...),
    date: str = Form(...),
    semester: str = Form(...),
    design_requirements: Optional[str] = Form(None),
    knowledge_and_tech: Optional[str] = Form(None),
    completion: Optional[str] = Form(None),
    self_statement: Optional[str] = Form(None),
    cover_template: str = Form(...),
    body_template: str = Form(...)
):
    """生成报告"""
    try:
        # 准备用户信息
        user_info = {
            "name": name,
            "student_id": student_id,
            "class_name": class_name,
            "instructor": instructor,
            "project_name": project_name,
            "date": date,
            "semester": semester
        }
        
        # 准备报告内容
        report_content = {}
        
        # 处理可选字段
        optional_fields = {
            "design_requirements": design_requirements,
            "knowledge_and_tech": knowledge_and_tech,
            "completion": completion,
            "self_statement": self_statement
        }
        
        for field, value in optional_fields.items():
            if value:
                # 使用AI生成内容
                prompt = f"请根据训练内容，生成关于{field}的详细描述"
                context = await ai_service.search_similar_documents(query)
                context_text = "\n".join([doc['content'] for doc in context])
                
                generated_content = await ai_service.generate_report_with_prompt(
                    query, prompt, context_text
                )
                report_content[field] = generated_content
            else:
                # 使用简短提示生成
                prompt = f"请简要描述{field}相关内容"
                generated_content = await ai_service.generate_report_with_prompt(
                    query, prompt
                )
                report_content[field] = generated_content
        
        # 生成主报告内容
        main_prompt = f"""
        请根据以下查询内容生成详细的实训报告正文：
        
        查询内容：{query}
        
        要求：
        1. 内容要详细、专业
        2. 结构清晰，逻辑合理
        3. 包含技术细节和实现过程
        4. 字数控制在2000-3000字
        """
        
        context = await ai_service.search_similar_documents(query)
        context_text = "\n".join([doc['content'] for doc in context])
        
        main_content = await ai_service.generate_report_with_prompt(
            query, main_prompt, context_text
        )
        
        report_content["main_content"] = main_content
        
        # 生成报告文档
        session_id = str(uuid.uuid4())
        session_dir = os.path.join("temp", session_id)
        os.makedirs(session_dir, exist_ok=True)
        
        template_path = os.path.dirname(cover_template)
        final_path = await report_generator.generate_report(
            template_path, report_content, user_info, [], session_dir
        )
        
        return {
            "message": "报告生成成功",
            "download_url": f"/download/{session_id}/final_report.docx"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/download/{session_id}/{filename}")
async def download_file(session_id: str, filename: str):
    """下载生成的文件"""
    try:
        file_path = os.path.join("temp", session_id, filename)
        if os.path.exists(file_path):
            return FileResponse(file_path, filename=filename)
        else:
            raise HTTPException(status_code=404, detail="文件不存在")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

#### 3.4.2 错误处理
```python
from fastapi import HTTPException
from fastapi.responses import JSONResponse
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """全局异常处理"""
    logger.error(f"未处理的异常: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "服务器内部错误"}
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    """HTTP异常处理"""
    logger.error(f"HTTP异常: {exc.detail}")
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail}
    )
```

## 4. 开发流程

### 4.1 环境准备
1. 安装Python 3.8+
2. 安装依赖：
```bash
pip install -r requirements.txt
```

### 4.2 配置设置
1. 创建 `.env` 文件：
```env
AI_API_URL=http://localhost:11434/api/generate
AI_MODEL_NAME=qwen2.5:7b
AI_API_KEY=your_api_key
DEBUG=True
HOST=0.0.0.0
PORT=8000
```

### 4.3 开发步骤
1. 启动开发服务器：
```bash
uvicorn app:app --reload --host 0.0.0.0 --port 8000
```

2. 修改前端代码：
- 编辑 `static/js/main.js`
- 编辑 `static/css/style.css`
- 编辑 `templates/index.html`

3. 修改后端代码：
- 编辑 `app.py`
- 编辑 `services/*.py`

4. 测试：
- 上传测试文件
- 检查生成报告
- 验证功能正常

## 5. 部署说明

### 5.1 Docker部署（推荐）

1. 构建镜像：
```bash
docker-compose build
```

2. 启动服务：
```bash
docker-compose up -d
```

3. 查看日志：
```bash
docker-compose logs -f
```

### 5.2 直接部署

1. 安装依赖：
```bash
pip install -r requirements.txt
```

2. 使用 Screen 启动服务：
```bash
screen -S rag-uvicorn
uvicorn app:app --host 0.0.0.0 --port 8000
# Ctrl+A, D 分离会话
```

### 5.3 配置 Nginx（可选）

```nginx
server {
    listen 80;
    server_name your_domain.com;

    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

## 6. API文档

### 6.1 文件上传
```
POST /upload
Content-Type: multipart/form-data

参数：
- cover_template: 封面模板文件
- body_template: 正文模板文件
- files: 资料文件
```

### 6.2 生成报告
```
POST /generate_report
Content-Type: multipart/form-data

参数：
- query: 查询内容
- name: 姓名
- student_id: 学号
- class_name: 班级
- instructor: 导师
- project_name: 项目名称
- ...其他字段
```

## 7. 常见问题

### 7.1 文件上传失败
- 检查文件大小限制
- 检查文件格式是否支持
- 检查存储目录权限

### 7.2 报告生成失败
- 检查AI服务连接
- 检查模板格式
- 检查日志输出

### 7.3 服务异常
- 检查端口占用
- 检查内存使用
- 检查日志记录

## 8. 开发建议

### 8.1 代码规范
- 遵循PEP 8规范
- 使用类型注解
- 添加适当的注释
- 使用异步函数处理IO

### 8.2 安全建议
- 验证文件类型
- 限制文件大小
- 清理临时文件
- 保护API密钥

### 8.3 性能优化
- 使用异步IO
- 优化向量检索
- 合理使用缓存
- 控制并发请求

## 9. 维护指南

### 9.1 日常维护
1. 检查日志文件
2. 清理临时文件
3. 备份重要数据
4. 更新依赖包

### 9.2 故障处理
1. 查看错误日志
2. 检查服务状态
3. 重启服务
4. 恢复数据

### 9.3 升级流程
1. 备份数据
2. 更新代码
3. 安装依赖
4. 测试功能
5. 重启服务

## 10. 联系与支持

- 项目维护者：[维护者姓名]
- 联系邮箱：[邮箱地址]
- 问题反馈：[Issue链接]
- 技术支持：[支持渠道] 